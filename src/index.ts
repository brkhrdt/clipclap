import { app, BrowserWindow, clipboard, ipcMain, nativeTheme, Menu, MenuItemConstructorOptions } from 'electron';
import { WebContents, MenuItem } from 'electron';
import { PathLike, existsSync } from 'fs';

import logger from './logger'; // Import the logger
import EVENTS from './events';
// import { ClipboardHistory } from './history';
import { Clip } from './clip';
import { filterHistory } from './search';
import { ClipboardHistory } from './history';
import { readConfig } from './settings';

import LLM from './llm';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
    app.quit();
}

const maxHistorySize = 30;
let clipboardHistory = new ClipboardHistory(maxHistorySize);

const CLIPBOARD_POLL_RATE = 1000;
let CURRENT_FILTER_QUERY = '';

const APP_DIR = app.getAppPath();

let rendererContents: WebContents | null = null;

function createWindow() {
    const win = new BrowserWindow({
        width: 800,
        height: 600,
        webPreferences: {
            // nodeIntegration: true, // needed otherwise preload.js fails to require events
            // contextIsolation: false,
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
    });

    // TODO: set entire history first, later just add new clips
    rendererContents = win.webContents;
    logger.info(typeof rendererContents);

    const configFile = getConfigFile();
    const config = readConfig(configFile);

    nativeTheme.themeSource = config.theme;
    logger.debug(`Config: ${config}`);
    logger.debug(JSON.stringify(config));
    win.webContents.send(EVENTS.LOAD_CONFIG, config);

    win.webContents.send(EVENTS.CLIPBOARD_UPDATED, clipboardHistory.getClips());

    win.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    logger.info('Window created and loaded.');
    // run_llm();

    // Create a custom menu
    const menuTemplate: Electron.MenuItemConstructorOptions[] = [
        {
            label: 'Menu Item 1',
            click: () => { logger.info('clicked')}
        },
        { type: 'separator' },
        {
            label: 'View',
            submenu: [
                { role: 'reload' },
                { role: 'forceReload' },
                { role: 'toggleDevTools' },
                { type: 'separator' },
                { role: 'resetZoom' },
                { role: 'zoomIn' },
                { role: 'zoomOut' },
            ]
        },
        { type: 'separator' },
        {
            label: 'Editor',
            submenu: [
                {
                    label: 'Line wrap',
                    type: 'checkbox',
                    checked: config.lineWrap
                    click: () => {
                        config.lineWrap = config.lineWrap ? false : true;
                        win.webContents.send(EVENTS.LOAD_CONFIG, config);
                    }
                },
                { label: 'Line numbers'},
                { label: 'Highlight whitespace'},
                {
                    label: 'Colorscheme',
                    submenu: [
                        {
                            label: 'System',
                            type: 'radio',
                            click: () => {
                                config.theme = 'system';
                                win.webContents.send(EVENTS.LOAD_CONFIG, config);
                                nativeTheme.themeSource = config.theme;
                            }
                        },
                        {
                            label: 'Light'
                            type: 'radio',
                            click: () => {
                                config.theme = 'light';
                                win.webContents.send(EVENTS.LOAD_CONFIG, config);
                                nativeTheme.themeSource = config.theme;
                            }
                        },
                        {
                            label: 'Dark'
                            type: 'radio',
                            click: () => {
                                config.theme = 'dark';
                                win.webContents.send(EVENTS.LOAD_CONFIG, config);
                                nativeTheme.themeSource = config.theme;
                            }
                        }
                    ]
                }
                {
                    label: 'Models',
                    submenu: [
                        {
                            label: 'model 1',
                            type: 'radio',
                        },
                        {
                            label: 'model 2',
                            type: 'radio',
                        },
                        {
                            label: 'model 2',
                            type: 'radio',
                        }
                    ]
                }
            ]
        }
        { type: 'separator' },
        {
            role: 'help',
            submenu: [
                {
                    label: 'About',
                    click: async () => {
                        const { shell } = require('electron')
                        await shell.openExternal('https://github.com')
                    }
                }
            ]
        }
    ]

    const menu = Menu.buildFromTemplate(menuTemplate);
    Menu.setApplicationMenu(menu);

    watchClipboard();
}


function watchClipboard() {
    let lastClipboardText = clipboard.readText();
    logger.info('Started monitoring clipboard.');

    let clipCount: number = 0;

    setInterval(() => {
        const currentClipboardText = clipboard.readText();

        if (
            currentClipboardText &&
            currentClipboardText !== lastClipboardText
        ) {
            clipCount += 1; // Used as ID
            lastClipboardText = currentClipboardText;
            logger.debug(`Clipboard contents: ${lastClipboardText}`);

            const clip: Clip = {
                id: clipCount,
                date: new Date(),
                data: currentClipboardText,
            };
            clipboardHistory.addClip(clip);
            logger.debug(`History: ${clipboardHistory}`);

            logger.info('Clipboard updated: ', { text: currentClipboardText });
            updateClipboardOnRenderer();
        }
    }, CLIPBOARD_POLL_RATE);
}

function updateClipboardOnRenderer() {
    if (rendererContents) {
        if (CURRENT_FILTER_QUERY != '') {
            logger.debug(`Active filter: ${CURRENT_FILTER_QUERY}`);
            filterHistory(
                CURRENT_FILTER_QUERY,
                clipboardHistory.getClips()
            ).then((filteredHistory) => {
                rendererContents.send(
                    EVENTS.CLIPBOARD_UPDATED,
                    filteredHistory
                );
            });
        } else {
            rendererContents.send(
                EVENTS.CLIPBOARD_UPDATED,
                clipboardHistory.getClips()
            );
        }
    }
}

function setupIPC() {
    // Bi-directional communication: Handle data fetch request
    ipcMain.handle(EVENTS.PROMPT_LLM, async (event, prompt, text) => {
        logger.debug(`${event} ${prompt}`);
        const baseurl = 'http://localhost:11434/v1';
        const apikey = 'ollama';
        const systemprompt = `You are an expert assistant and will be given some text to modify based on the user\'s request. Only modify the given text. Be concise and do not give any information that is not asked for.\n\nHere is the text:\n${text}`;

        const llm = new LLM(baseurl, apikey, systemprompt);
        // TODO handle failed connection
        return await llm.runLLM(prompt);
    });

    ipcMain.handle(EVENTS.FILTER_HISTORY, async (event, query) => {
        CURRENT_FILTER_QUERY = query;
        logger.debug(`${event} ${query}`);
        return await filterHistory(query, clipboardHistory.getClips());
    });

    // // Uni-directional communication: Handle logging request
    ipcMain.on(EVENTS.UPDATE_CLIP, (event, clip) => {
        logger.debug('Update clip from renderer:', clip);
        clipboardHistory.updateClip(clip);
        updateClipboardOnRenderer();
    });

    // // Periodic updates (can be either uni- or bi-directional)
    // ipcMain.handle('get-system-info', () => {
    //     return { cpu: 'Intel', ram: '16GB' };
    // });
}

function getUserDir(): PathLike | null {
    // Return the directory to configure the app depending on platform
    const appUserDir = app.getPath('userData');
    logger.debug(`User dir is ${appUserDir}`);

    return existsSync(appUserDir) ? appUserDir : null;
}

function getConfigFile(): PathLike | null {
    const appConfigDir = getUserDir();
    const appConfigFile = appConfigDir ? `${appConfigDir}/config.json` : null;

    if (appConfigFile && existsSync(appConfigFile)) {
        logger.debug(`Config dir is ${appConfigDir}`);
        return appConfigFile;
    }

    logger.debug(`Config file does not exist ${appConfigFile}`);
    return null;
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
// app.on('ready', createWindow);
app.whenReady().then(() => {
    createWindow();
    setupIPC();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
